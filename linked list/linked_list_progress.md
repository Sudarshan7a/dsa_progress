## **DSA Progress Tracker â€” Day 2**

_(Topic: Singly Linked List)_

### âœ… Covered

- **Concept & Structure** _(Easy)_:
  - Nodes with `data` and `next` pointer
  - `head` pointer as entry point
  - Last node points to `None`
- **Comparison with Arrays** _(Easy)_:
  - Linked list faster insertion/deletion at start _(O(1))_
  - Arrays faster random access _(O(1))_
- **Core Operations**:
  - `append(data)` _(Easy)_
  - `prepend(data)` _(Easy)_
  - `insert_after_node(prev_node, data)` _(Easy)_
  - `delete_node(key)` _(Easyâ€“Medium)_
  - `delete_node_at_pos(pos)` _(Easyâ€“Medium)_
  - `len_iterative()` _(Easy)_
  - `len_recursive()` _(Medium)_
  - `swap_nodes(key_1, key_2)` _(Mediumâ€“Hard)_ â† **first â€œhardâ€ moment**

---

### ğŸ”œ Pending for Mastery

- **Implementation Variations**:
  - Circular Singly Linked List _(Medium)_
- **Advanced Operations**:
  - Reverse Linked List (iterative & recursive) _(Mediumâ€“Hard)_
  - Detect & Remove Cycle (Floydâ€™s Cycle Detection) _(Mediumâ€“Hard)_
  - Merge Two Sorted Linked Lists _(Medium)_
  - Find Middle Node _(Easyâ€“Medium)_
  - N-th node from end (two-pointer technique) _(Medium)_
  - Delete Linked List _(Easy)_
  - Clone Linked List with Random Pointer _(Hard)_
- **Applications**:
  - Implement stack/queue using linked list _(Medium)_
  - Polynomial representation _(Medium)_
